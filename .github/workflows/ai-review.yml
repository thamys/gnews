name: AI Code Review

# Trigger: executa quando um Pull Request é aberto ou atualizado
on:
  pull_request:
    types: [opened, synchronize]

jobs:
  review:
    runs-on: ubuntu-latest
    
    # Permissões necessárias para o job
    permissions:
      contents: read          # Permite ler o conteúdo do repositório
      pull-requests: write    # Permite comentar no Pull Request

    steps:
      # Passo 1: Faz checkout do código do repositório
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0      # Busca todo o histórico para análise completa

      # Passo 2: Executa a revisão de código com Gemini AI
      # Documentação completa: https://github.com/sshnaidm/gemini-code-review-action#configuration-options
      - name: Gemini Flash Reviewer
        id: gemini-review
        uses: sshnaidm/gemini-code-review-action@v1
        env:
          # Define a variável de ambiente que a action espera
          GEMINI_API_KEY: ${{ secrets.AI_API_KEY }}
        with:
          # Modelo do Gemini a ser utilizado (Flash é rápido e econômico)
          model: gemini-2.5-flash
          
          # Chave da API do Gemini (IMPORTANTE: usar hífen, não underscore)
          gemini-key: ${{ secrets.AI_API_KEY }}
          
          # Token do GitHub para autenticação (opcional, usa o padrão se omitido)
          github-token: ${{ secrets.GITHUB_TOKEN }}
          
          # Prompt customizado para o revisor de código
          prompt: |
            Você é um Engenheiro de Segurança Sênior (DevSecOps).
            
            IMPORTANTE: NÃO repita o diff completo na sua resposta.
            
            Analise APENAS as mudanças do código e responda de forma CONCISA:
            
            1. Liste APENAS as vulnerabilidades encontradas no seguinte formato:
               - **[CRÍTICO/ALTO/MÉDIO/BAIXO]** `arquivo.java:linha` - Tipo de vulnerabilidade (ex: SQL Injection - OWASP A03)
               - Descrição breve (1-2 linhas)
               - Recomendação de correção (1-2 linhas)
            
            2. Se encontrar vulnerabilidades OWASP Top 10, marque como [CRÍTICO]
            
            3. Code smells e complexidade ciclomática devem ser marcados como [MÉDIO] ou [BAIXO]
            
            4. Se NÃO houver problemas, responda apenas: "✅ Nenhuma vulnerabilidade ou problema crítico encontrado."
            
            Foco em: SQL Injection, Insecure Deserialization, e boas práticas Java 25/Spring Boot 3.4.

      # Passo 3: Valida se há vulnerabilidades críticas e falha o workflow
      - name: Check for Critical Vulnerabilities
        if: always()
        run: |
          echo "Verificando se há vulnerabilidades críticas no código..."
          
          # Busca por padrões de SQL Injection no código alterado
          if git diff HEAD~1 HEAD | grep -E "SELECT.*FROM.*WHERE.*\+.*userInput|query.*=.*\".*'.*\+"; then
            echo "❌ CRÍTICO: SQL Injection detectado no código!"
            echo "O merge está BLOQUEADO até que a vulnerabilidade seja corrigida."
            exit 1
          fi
          
          # Busca por concatenação de strings em queries SQL
          if git diff HEAD~1 HEAD | grep -E "jdbcTemplate\.query\(.*\+.*\)"; then
            echo "❌ CRÍTICO: Possível SQL Injection - uso de concatenação em query SQL!"
            echo "Use consultas parametrizadas (PreparedStatement ou JdbcTemplate com placeholders)."
            exit 1
          fi
          
          echo "✅ Nenhuma vulnerabilidade crítica detectada. Merge permitido."
